// Autogenerated with StateSmith 0.19.0-alpha-1+5931a3a68e50c80e83349118a90569bf08270686.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#nullable enable

namespace BeziqueCore;

// Generated state machine
public partial class BeziqueGameState
{
    public enum EventId
    {
        ALLHANDSEMPTY = 0,
        CARDPLAYED = 1,
        CARDSDEALT = 2,
        CARDSDRAWN = 3,
        CONTINUEGAME = 4,
        CONTINUELASTNINE = 5,
        DECKEMPTY = 6,
        INITIALIZED = 7,
        MELDDECLARED = 8,
        MELDSCORED = 9,
        MELDSKIPPED = 10,
        MORECARDSAVAILABLE = 11,
        MOREPLAYERSNEEDTOPLAY = 12,
        TIMEREXPIRED = 13,
        TIMERRESET = 14,
        TRICKCOMPLETE = 15,
        TRICKRESOLVED = 16,
        TRUMPDETERMINED = 17,
        WINNINGSCOREREACHED = 18,
    }

    public const int EventIdCount = 19;

    public enum StateId
    {
        ROOT = 0,
        DEALING = 1,
        GAME_INIT = 2,
        GAME_OVER = 3,
        GAMEPLAY = 4,
        CARD_DRAW = 5,
        DECK_CHECK = 6,
        LAST_9_CARDS = 7,
        L9_OPPONENT_RESPONSE = 8,
        L9_PLAYER_TURN = 9,
        L9_TIMER_TIMEOUT = 10,
        L9_TRICK_CHECK = 11,
        L9_TRICK_RESOLUTION = 12,
        MELD_OPPORTUNITY = 13,
        MELD_SCORING = 14,
        OPPONENT_RESPONSE = 15,
        PLAYER_TURN = 16,
        TRICK_RESOLUTION = 17,
        ROUND_END = 18,
        TIMER_TIMEOUT = 19,
        TRUMP_SELECTION = 20,
    }

    public const int StateIdCount = 21;

    // Used internally by state machine. Feel free to inspect, but don't modify.
    public StateId stateId;

    // State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
    public BeziqueGameState()
    {
    }

    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    public void Start()
    {
        ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

            // ROOT.<InitialState> behavior
            // uml: TransitionTo(GAME_INIT)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `GAME_INIT`.
                GAME_INIT_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }

    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    public void DispatchEvent(EventId eventId)
    {
        switch (this.stateId)
        {
            // STATE: BeziqueGameState
            case StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: DEALING
            case StateId.DEALING:
                switch (eventId)
                {
                    case EventId.CARDSDEALT: DEALING_cardsdealt(); break;
                }
                break;

            // STATE: GAME_INIT
            case StateId.GAME_INIT:
                switch (eventId)
                {
                    case EventId.INITIALIZED: GAME_INIT_initialized(); break;
                }
                break;

            // STATE: GAME_OVER
            case StateId.GAME_OVER:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: GAMEPLAY
            case StateId.GAMEPLAY:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: CARD_DRAW
            case StateId.CARD_DRAW:
                switch (eventId)
                {
                    case EventId.CARDSDRAWN: CARD_DRAW_cardsdrawn(); break;
                }
                break;

            // STATE: DECK_CHECK
            case StateId.DECK_CHECK:
                switch (eventId)
                {
                    case EventId.DECKEMPTY: DECK_CHECK_deckempty(); break;
                    case EventId.MORECARDSAVAILABLE: DECK_CHECK_morecardsavailable(); break;
                }
                break;

            // STATE: LAST_9_CARDS
            case StateId.LAST_9_CARDS:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: L9_OPPONENT_RESPONSE
            case StateId.L9_OPPONENT_RESPONSE:
                switch (eventId)
                {
                    case EventId.TRICKCOMPLETE: L9_OPPONENT_RESPONSE_trickcomplete(); break;
                    case EventId.MOREPLAYERSNEEDTOPLAY: L9_OPPONENT_RESPONSE_moreplayersneedtoplay(); break;
                }
                break;

            // STATE: L9_PLAYER_TURN
            case StateId.L9_PLAYER_TURN:
                switch (eventId)
                {
                    case EventId.CARDPLAYED: L9_PLAYER_TURN_cardplayed(); break;
                    case EventId.TIMEREXPIRED: L9_PLAYER_TURN_timerexpired(); break;
                }
                break;

            // STATE: L9_TIMER_TIMEOUT
            case StateId.L9_TIMER_TIMEOUT:
                switch (eventId)
                {
                    case EventId.TIMERRESET: L9_TIMER_TIMEOUT_timerreset(); break;
                }
                break;

            // STATE: L9_TRICK_CHECK
            case StateId.L9_TRICK_CHECK:
                switch (eventId)
                {
                    case EventId.CONTINUELASTNINE: L9_TRICK_CHECK_continuelastnine(); break;
                    case EventId.ALLHANDSEMPTY: L9_TRICK_CHECK_allhandsempty(); break;
                }
                break;

            // STATE: L9_TRICK_RESOLUTION
            case StateId.L9_TRICK_RESOLUTION:
                switch (eventId)
                {
                    case EventId.TRICKRESOLVED: L9_TRICK_RESOLUTION_trickresolved(); break;
                    case EventId.WINNINGSCOREREACHED: L9_TRICK_RESOLUTION_winningscorereached(); break;
                }
                break;

            // STATE: MELD_OPPORTUNITY
            case StateId.MELD_OPPORTUNITY:
                switch (eventId)
                {
                    case EventId.MELDDECLARED: MELD_OPPORTUNITY_melddeclared(); break;
                    case EventId.MELDSKIPPED: MELD_OPPORTUNITY_meldskipped(); break;
                }
                break;

            // STATE: MELD_SCORING
            case StateId.MELD_SCORING:
                switch (eventId)
                {
                    case EventId.MELDSCORED: MELD_SCORING_meldscored(); break;
                    case EventId.WINNINGSCOREREACHED: MELD_SCORING_winningscorereached(); break;
                }
                break;

            // STATE: OPPONENT_RESPONSE
            case StateId.OPPONENT_RESPONSE:
                switch (eventId)
                {
                    case EventId.TRICKCOMPLETE: OPPONENT_RESPONSE_trickcomplete(); break;
                    case EventId.MOREPLAYERSNEEDTOPLAY: OPPONENT_RESPONSE_moreplayersneedtoplay(); break;
                }
                break;

            // STATE: PLAYER_TURN
            case StateId.PLAYER_TURN:
                switch (eventId)
                {
                    case EventId.CARDPLAYED: PLAYER_TURN_cardplayed(); break;
                    case EventId.TIMEREXPIRED: PLAYER_TURN_timerexpired(); break;
                }
                break;

            // STATE: TRICK_RESOLUTION
            case StateId.TRICK_RESOLUTION:
                switch (eventId)
                {
                    case EventId.TRICKRESOLVED: TRICK_RESOLUTION_trickresolved(); break;
                    case EventId.WINNINGSCOREREACHED: TRICK_RESOLUTION_winningscorereached(); break;
                }
                break;

            // STATE: ROUND_END
            case StateId.ROUND_END:
                switch (eventId)
                {
                    case EventId.CONTINUEGAME: ROUND_END_continuegame(); break;
                    case EventId.WINNINGSCOREREACHED: ROUND_END_winningscorereached(); break;
                }
                break;

            // STATE: TIMER_TIMEOUT
            case StateId.TIMER_TIMEOUT:
                switch (eventId)
                {
                    case EventId.TIMERRESET: TIMER_TIMEOUT_timerreset(); break;
                }
                break;

            // STATE: TRUMP_SELECTION
            case StateId.TRUMP_SELECTION:
                switch (eventId)
                {
                    case EventId.TRUMPDETERMINED: TRUMP_SELECTION_trumpdetermined(); break;
                }
                break;
        }

    }

    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    private void ExitUpToStateHandler(StateId desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case StateId.DEALING: DEALING_exit(); break;

                case StateId.GAME_INIT: GAME_INIT_exit(); break;

                case StateId.GAME_OVER: GAME_OVER_exit(); break;

                case StateId.GAMEPLAY: GAMEPLAY_exit(); break;

                case StateId.CARD_DRAW: CARD_DRAW_exit(); break;

                case StateId.DECK_CHECK: DECK_CHECK_exit(); break;

                case StateId.LAST_9_CARDS: LAST_9_CARDS_exit(); break;

                case StateId.L9_OPPONENT_RESPONSE: L9_OPPONENT_RESPONSE_exit(); break;

                case StateId.L9_PLAYER_TURN: L9_PLAYER_TURN_exit(); break;

                case StateId.L9_TIMER_TIMEOUT: L9_TIMER_TIMEOUT_exit(); break;

                case StateId.L9_TRICK_CHECK: L9_TRICK_CHECK_exit(); break;

                case StateId.L9_TRICK_RESOLUTION: L9_TRICK_RESOLUTION_exit(); break;

                case StateId.MELD_OPPORTUNITY: MELD_OPPORTUNITY_exit(); break;

                case StateId.MELD_SCORING: MELD_SCORING_exit(); break;

                case StateId.OPPONENT_RESPONSE: OPPONENT_RESPONSE_exit(); break;

                case StateId.PLAYER_TURN: PLAYER_TURN_exit(); break;

                case StateId.TRICK_RESOLUTION: TRICK_RESOLUTION_exit(); break;

                case StateId.ROUND_END: ROUND_END_exit(); break;

                case StateId.TIMER_TIMEOUT: TIMER_TIMEOUT_exit(); break;

                case StateId.TRUMP_SELECTION: TRUMP_SELECTION_exit(); break;

                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////

    private void ROOT_enter()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DEALING
    ////////////////////////////////////////////////////////////////////////////////

    private void DEALING_enter()
    {
        this.stateId = StateId.DEALING;

        // DEALING behavior
        // uml: enter / { _adapter.DealCards(); }
        {
            // Step 1: execute action `_adapter.DealCards();`
            _adapter.DealCards();
        } // end of behavior for DEALING
    }

    private void DEALING_exit()
    {
        // DEALING behavior
        // uml: exit / { _adapter.NotifyCardsDealt(); }
        {
            // Step 1: execute action `_adapter.NotifyCardsDealt();`
            _adapter.NotifyCardsDealt();
        } // end of behavior for DEALING

        this.stateId = StateId.ROOT;
    }

    private void DEALING_cardsdealt()
    {
        // DEALING behavior
        // uml: CardsDealt TransitionTo(TRUMP_SELECTION)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            DEALING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `TRUMP_SELECTION`.
            TRUMP_SELECTION_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DEALING

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state GAME_INIT
    ////////////////////////////////////////////////////////////////////////////////

    private void GAME_INIT_enter()
    {
        this.stateId = StateId.GAME_INIT;

        // GAME_INIT behavior
        // uml: enter / { _adapter.InitializeGame(); }
        {
            // Step 1: execute action `_adapter.InitializeGame();`
            _adapter.InitializeGame();
        } // end of behavior for GAME_INIT
    }

    private void GAME_INIT_exit()
    {
        // GAME_INIT behavior
        // uml: exit / { _adapter.NotifyGameInitialized(); }
        {
            // Step 1: execute action `_adapter.NotifyGameInitialized();`
            _adapter.NotifyGameInitialized();
        } // end of behavior for GAME_INIT

        this.stateId = StateId.ROOT;
    }

    private void GAME_INIT_initialized()
    {
        // GAME_INIT behavior
        // uml: Initialized TransitionTo(DEALING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            GAME_INIT_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `DEALING`.
            DEALING_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for GAME_INIT

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state GAME_OVER
    ////////////////////////////////////////////////////////////////////////////////

    private void GAME_OVER_enter()
    {
        this.stateId = StateId.GAME_OVER;

        // GAME_OVER behavior
        // uml: enter / { _adapter.DeclareWinner(); }
        {
            // Step 1: execute action `_adapter.DeclareWinner();`
            _adapter.DeclareWinner();
        } // end of behavior for GAME_OVER
    }

    private void GAME_OVER_exit()
    {
        // GAME_OVER behavior
        // uml: exit / { _adapter.NotifyGameOver(); }
        {
            // Step 1: execute action `_adapter.NotifyGameOver();`
            _adapter.NotifyGameOver();
        } // end of behavior for GAME_OVER

        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state GAMEPLAY
    ////////////////////////////////////////////////////////////////////////////////

    private void GAMEPLAY_enter()
    {
        this.stateId = StateId.GAMEPLAY;
    }

    private void GAMEPLAY_exit()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state CARD_DRAW
    ////////////////////////////////////////////////////////////////////////////////

    private void CARD_DRAW_enter()
    {
        this.stateId = StateId.CARD_DRAW;

        // CARD_DRAW behavior
        // uml: enter / { _adapter.DrawCards(); }
        {
            // Step 1: execute action `_adapter.DrawCards();`
            _adapter.DrawCards();
        } // end of behavior for CARD_DRAW
    }

    private void CARD_DRAW_exit()
    {
        this.stateId = StateId.GAMEPLAY;
    }

    private void CARD_DRAW_cardsdrawn()
    {
        // CARD_DRAW behavior
        // uml: CardsDrawn TransitionTo(DECK_CHECK)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            CARD_DRAW_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `DECK_CHECK`.
            DECK_CHECK_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CARD_DRAW

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state DECK_CHECK
    ////////////////////////////////////////////////////////////////////////////////

    private void DECK_CHECK_enter()
    {
        this.stateId = StateId.DECK_CHECK;

        // DECK_CHECK behavior
        // uml: enter / { _adapter.CheckDeck(); }
        {
            // Step 1: execute action `_adapter.CheckDeck();`
            _adapter.CheckDeck();
        } // end of behavior for DECK_CHECK
    }

    private void DECK_CHECK_exit()
    {
        this.stateId = StateId.GAMEPLAY;
    }

    private void DECK_CHECK_deckempty()
    {
        // DECK_CHECK behavior
        // uml: DeckEmpty TransitionTo(LAST_9_CARDS)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            DECK_CHECK_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `LAST_9_CARDS`.
            LAST_9_CARDS_enter();

            // LAST_9_CARDS.<InitialState> behavior
            // uml: TransitionTo(L9_PLAYER_TURN)
            {
                // Step 1: Exit states until we reach `LAST_9_CARDS` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `L9_PLAYER_TURN`.
                L9_PLAYER_TURN_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for LAST_9_CARDS.<InitialState>
        } // end of behavior for DECK_CHECK

        // No ancestor handles this event.
    }

    private void DECK_CHECK_morecardsavailable()
    {
        // DECK_CHECK behavior
        // uml: MoreCardsAvailable TransitionTo(PLAYER_TURN)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            DECK_CHECK_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `PLAYER_TURN`.
            PLAYER_TURN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for DECK_CHECK

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state LAST_9_CARDS
    ////////////////////////////////////////////////////////////////////////////////

    private void LAST_9_CARDS_enter()
    {
        this.stateId = StateId.LAST_9_CARDS;
    }

    private void LAST_9_CARDS_exit()
    {
        this.stateId = StateId.GAMEPLAY;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state L9_OPPONENT_RESPONSE
    ////////////////////////////////////////////////////////////////////////////////

    private void L9_OPPONENT_RESPONSE_enter()
    {
        this.stateId = StateId.L9_OPPONENT_RESPONSE;

        // L9_OPPONENT_RESPONSE behavior
        // uml: enter / { _adapter.ProcessL9OpponentResponses(); }
        {
            // Step 1: execute action `_adapter.ProcessL9OpponentResponses();`
            _adapter.ProcessL9OpponentResponses();
        } // end of behavior for L9_OPPONENT_RESPONSE
    }

    private void L9_OPPONENT_RESPONSE_exit()
    {
        this.stateId = StateId.LAST_9_CARDS;
    }

    private void L9_OPPONENT_RESPONSE_moreplayersneedtoplay()
    {
        // L9_OPPONENT_RESPONSE behavior
        // uml: MorePlayersNeedToPlay TransitionTo(L9_PLAYER_TURN)
        {
            // Step 1: Exit states until we reach `LAST_9_CARDS` state (Least Common Ancestor for transition).
            L9_OPPONENT_RESPONSE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `L9_PLAYER_TURN`.
            L9_PLAYER_TURN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_OPPONENT_RESPONSE

        // No ancestor handles this event.
    }

    private void L9_OPPONENT_RESPONSE_trickcomplete()
    {
        // L9_OPPONENT_RESPONSE behavior
        // uml: TrickComplete TransitionTo(L9_TRICK_RESOLUTION)
        {
            // Step 1: Exit states until we reach `LAST_9_CARDS` state (Least Common Ancestor for transition).
            L9_OPPONENT_RESPONSE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `L9_TRICK_RESOLUTION`.
            L9_TRICK_RESOLUTION_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_OPPONENT_RESPONSE

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state L9_PLAYER_TURN
    ////////////////////////////////////////////////////////////////////////////////

    private void L9_PLAYER_TURN_enter()
    {
        this.stateId = StateId.L9_PLAYER_TURN;

        // L9_PLAYER_TURN behavior
        // uml: enter / { _adapter.StartPlayerTimer(); }
        {
            // Step 1: execute action `_adapter.StartPlayerTimer();`
            _adapter.StartPlayerTimer();
        } // end of behavior for L9_PLAYER_TURN
    }

    private void L9_PLAYER_TURN_exit()
    {
        // L9_PLAYER_TURN behavior
        // uml: exit / { _adapter.StopPlayerTimer(); }
        {
            // Step 1: execute action `_adapter.StopPlayerTimer();`
            _adapter.StopPlayerTimer();
        } // end of behavior for L9_PLAYER_TURN

        this.stateId = StateId.LAST_9_CARDS;
    }

    private void L9_PLAYER_TURN_cardplayed()
    {
        // L9_PLAYER_TURN behavior
        // uml: CardPlayed TransitionTo(L9_OPPONENT_RESPONSE)
        {
            // Step 1: Exit states until we reach `LAST_9_CARDS` state (Least Common Ancestor for transition).
            L9_PLAYER_TURN_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `L9_OPPONENT_RESPONSE`.
            L9_OPPONENT_RESPONSE_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_PLAYER_TURN

        // No ancestor handles this event.
    }

    private void L9_PLAYER_TURN_timerexpired()
    {
        // L9_PLAYER_TURN behavior
        // uml: TimerExpired TransitionTo(L9_TIMER_TIMEOUT)
        {
            // Step 1: Exit states until we reach `LAST_9_CARDS` state (Least Common Ancestor for transition).
            L9_PLAYER_TURN_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `L9_TIMER_TIMEOUT`.
            L9_TIMER_TIMEOUT_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_PLAYER_TURN

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state L9_TIMER_TIMEOUT
    ////////////////////////////////////////////////////////////////////////////////

    private void L9_TIMER_TIMEOUT_enter()
    {
        this.stateId = StateId.L9_TIMER_TIMEOUT;

        // L9_TIMER_TIMEOUT behavior
        // uml: enter / { _adapter.DeductTimeoutPoints(); }
        {
            // Step 1: execute action `_adapter.DeductTimeoutPoints();`
            _adapter.DeductTimeoutPoints();
        } // end of behavior for L9_TIMER_TIMEOUT
    }

    private void L9_TIMER_TIMEOUT_exit()
    {
        // L9_TIMER_TIMEOUT behavior
        // uml: exit / { _adapter.ResetPlayerTimer(); }
        {
            // Step 1: execute action `_adapter.ResetPlayerTimer();`
            _adapter.ResetPlayerTimer();
        } // end of behavior for L9_TIMER_TIMEOUT

        this.stateId = StateId.LAST_9_CARDS;
    }

    private void L9_TIMER_TIMEOUT_timerreset()
    {
        // L9_TIMER_TIMEOUT behavior
        // uml: TimerReset TransitionTo(L9_PLAYER_TURN)
        {
            // Step 1: Exit states until we reach `LAST_9_CARDS` state (Least Common Ancestor for transition).
            L9_TIMER_TIMEOUT_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `L9_PLAYER_TURN`.
            L9_PLAYER_TURN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_TIMER_TIMEOUT

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state L9_TRICK_CHECK
    ////////////////////////////////////////////////////////////////////////////////

    private void L9_TRICK_CHECK_enter()
    {
        this.stateId = StateId.L9_TRICK_CHECK;

        // L9_TRICK_CHECK behavior
        // uml: enter / { _adapter.CheckL9TrickComplete(); }
        {
            // Step 1: execute action `_adapter.CheckL9TrickComplete();`
            _adapter.CheckL9TrickComplete();
        } // end of behavior for L9_TRICK_CHECK
    }

    private void L9_TRICK_CHECK_exit()
    {
        this.stateId = StateId.LAST_9_CARDS;
    }

    private void L9_TRICK_CHECK_allhandsempty()
    {
        // L9_TRICK_CHECK behavior
        // uml: AllHandsEmpty TransitionTo(ROUND_END)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROUND_END`.
            ROUND_END_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_TRICK_CHECK

        // No ancestor handles this event.
    }

    private void L9_TRICK_CHECK_continuelastnine()
    {
        // L9_TRICK_CHECK behavior
        // uml: ContinueLastNine TransitionTo(L9_PLAYER_TURN)
        {
            // Step 1: Exit states until we reach `LAST_9_CARDS` state (Least Common Ancestor for transition).
            L9_TRICK_CHECK_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `L9_PLAYER_TURN`.
            L9_PLAYER_TURN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_TRICK_CHECK

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state L9_TRICK_RESOLUTION
    ////////////////////////////////////////////////////////////////////////////////

    private void L9_TRICK_RESOLUTION_enter()
    {
        this.stateId = StateId.L9_TRICK_RESOLUTION;

        // L9_TRICK_RESOLUTION behavior
        // uml: enter / { _adapter.ResolveL9Trick(); }
        {
            // Step 1: execute action `_adapter.ResolveL9Trick();`
            _adapter.ResolveL9Trick();
        } // end of behavior for L9_TRICK_RESOLUTION
    }

    private void L9_TRICK_RESOLUTION_exit()
    {
        this.stateId = StateId.LAST_9_CARDS;
    }

    private void L9_TRICK_RESOLUTION_trickresolved()
    {
        // L9_TRICK_RESOLUTION behavior
        // uml: TrickResolved TransitionTo(L9_TRICK_CHECK)
        {
            // Step 1: Exit states until we reach `LAST_9_CARDS` state (Least Common Ancestor for transition).
            L9_TRICK_RESOLUTION_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `L9_TRICK_CHECK`.
            L9_TRICK_CHECK_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_TRICK_RESOLUTION

        // No ancestor handles this event.
    }

    private void L9_TRICK_RESOLUTION_winningscorereached()
    {
        // L9_TRICK_RESOLUTION behavior
        // uml: WinningScoreReached TransitionTo(GAME_OVER)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `GAME_OVER`.
            GAME_OVER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for L9_TRICK_RESOLUTION

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state MELD_OPPORTUNITY
    ////////////////////////////////////////////////////////////////////////////////

    private void MELD_OPPORTUNITY_enter()
    {
        this.stateId = StateId.MELD_OPPORTUNITY;

        // MELD_OPPORTUNITY behavior
        // uml: enter / { _adapter.ProcessMeldOpportunity(); }
        {
            // Step 1: execute action `_adapter.ProcessMeldOpportunity();`
            _adapter.ProcessMeldOpportunity();
        } // end of behavior for MELD_OPPORTUNITY
    }

    private void MELD_OPPORTUNITY_exit()
    {
        this.stateId = StateId.GAMEPLAY;
    }

    private void MELD_OPPORTUNITY_melddeclared()
    {
        // MELD_OPPORTUNITY behavior
        // uml: MeldDeclared TransitionTo(MELD_SCORING)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            MELD_OPPORTUNITY_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `MELD_SCORING`.
            MELD_SCORING_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MELD_OPPORTUNITY

        // No ancestor handles this event.
    }

    private void MELD_OPPORTUNITY_meldskipped()
    {
        // MELD_OPPORTUNITY behavior
        // uml: MeldSkipped TransitionTo(CARD_DRAW)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            MELD_OPPORTUNITY_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `CARD_DRAW`.
            CARD_DRAW_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MELD_OPPORTUNITY

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state MELD_SCORING
    ////////////////////////////////////////////////////////////////////////////////

    private void MELD_SCORING_enter()
    {
        this.stateId = StateId.MELD_SCORING;

        // MELD_SCORING behavior
        // uml: enter / { _adapter.ScoreMeld(); }
        {
            // Step 1: execute action `_adapter.ScoreMeld();`
            _adapter.ScoreMeld();
        } // end of behavior for MELD_SCORING
    }

    private void MELD_SCORING_exit()
    {
        this.stateId = StateId.GAMEPLAY;
    }

    private void MELD_SCORING_meldscored()
    {
        // MELD_SCORING behavior
        // uml: MeldScored TransitionTo(CARD_DRAW)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            MELD_SCORING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `CARD_DRAW`.
            CARD_DRAW_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MELD_SCORING

        // No ancestor handles this event.
    }

    private void MELD_SCORING_winningscorereached()
    {
        // MELD_SCORING behavior
        // uml: WinningScoreReached TransitionTo(GAME_OVER)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `GAME_OVER`.
            GAME_OVER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MELD_SCORING

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state OPPONENT_RESPONSE
    ////////////////////////////////////////////////////////////////////////////////

    private void OPPONENT_RESPONSE_enter()
    {
        this.stateId = StateId.OPPONENT_RESPONSE;

        // OPPONENT_RESPONSE behavior
        // uml: enter / { _adapter.ProcessOpponentResponses(); }
        {
            // Step 1: execute action `_adapter.ProcessOpponentResponses();`
            _adapter.ProcessOpponentResponses();
        } // end of behavior for OPPONENT_RESPONSE
    }

    private void OPPONENT_RESPONSE_exit()
    {
        this.stateId = StateId.GAMEPLAY;
    }

    private void OPPONENT_RESPONSE_moreplayersneedtoplay()
    {
        // OPPONENT_RESPONSE behavior
        // uml: MorePlayersNeedToPlay TransitionTo(PLAYER_TURN)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            OPPONENT_RESPONSE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `PLAYER_TURN`.
            PLAYER_TURN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for OPPONENT_RESPONSE

        // No ancestor handles this event.
    }

    private void OPPONENT_RESPONSE_trickcomplete()
    {
        // OPPONENT_RESPONSE behavior
        // uml: TrickComplete TransitionTo(TRICK_RESOLUTION)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            OPPONENT_RESPONSE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `TRICK_RESOLUTION`.
            TRICK_RESOLUTION_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for OPPONENT_RESPONSE

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state PLAYER_TURN
    ////////////////////////////////////////////////////////////////////////////////

    private void PLAYER_TURN_enter()
    {
        this.stateId = StateId.PLAYER_TURN;

        // PLAYER_TURN behavior
        // uml: enter / { _adapter.StartPlayerTimer(); }
        {
            // Step 1: execute action `_adapter.StartPlayerTimer();`
            _adapter.StartPlayerTimer();
        } // end of behavior for PLAYER_TURN
    }

    private void PLAYER_TURN_exit()
    {
        // PLAYER_TURN behavior
        // uml: exit / { _adapter.StopPlayerTimer(); }
        {
            // Step 1: execute action `_adapter.StopPlayerTimer();`
            _adapter.StopPlayerTimer();
        } // end of behavior for PLAYER_TURN

        this.stateId = StateId.GAMEPLAY;
    }

    private void PLAYER_TURN_cardplayed()
    {
        // PLAYER_TURN behavior
        // uml: CardPlayed TransitionTo(OPPONENT_RESPONSE)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            PLAYER_TURN_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `OPPONENT_RESPONSE`.
            OPPONENT_RESPONSE_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYER_TURN

        // No ancestor handles this event.
    }

    private void PLAYER_TURN_timerexpired()
    {
        // PLAYER_TURN behavior
        // uml: TimerExpired TransitionTo(TIMER_TIMEOUT)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `TIMER_TIMEOUT`.
            TIMER_TIMEOUT_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for PLAYER_TURN

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRICK_RESOLUTION
    ////////////////////////////////////////////////////////////////////////////////

    private void TRICK_RESOLUTION_enter()
    {
        this.stateId = StateId.TRICK_RESOLUTION;

        // TRICK_RESOLUTION behavior
        // uml: enter / { _adapter.ResolveTrick(); }
        {
            // Step 1: execute action `_adapter.ResolveTrick();`
            _adapter.ResolveTrick();
        } // end of behavior for TRICK_RESOLUTION
    }

    private void TRICK_RESOLUTION_exit()
    {
        this.stateId = StateId.GAMEPLAY;
    }

    private void TRICK_RESOLUTION_trickresolved()
    {
        // TRICK_RESOLUTION behavior
        // uml: TrickResolved TransitionTo(MELD_OPPORTUNITY)
        {
            // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition).
            TRICK_RESOLUTION_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `MELD_OPPORTUNITY`.
            MELD_OPPORTUNITY_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TRICK_RESOLUTION

        // No ancestor handles this event.
    }

    private void TRICK_RESOLUTION_winningscorereached()
    {
        // TRICK_RESOLUTION behavior
        // uml: WinningScoreReached TransitionTo(GAME_OVER)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(StateId.ROOT);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `GAME_OVER`.
            GAME_OVER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TRICK_RESOLUTION

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROUND_END
    ////////////////////////////////////////////////////////////////////////////////

    private void ROUND_END_enter()
    {
        this.stateId = StateId.ROUND_END;

        // ROUND_END behavior
        // uml: enter / { _adapter.CalculateAcesAndTens(); }
        {
            // Step 1: execute action `_adapter.CalculateAcesAndTens();`
            _adapter.CalculateAcesAndTens();
        } // end of behavior for ROUND_END

        // ROUND_END behavior
        // uml: enter / { _adapter.CalculateRoundScores(); }
        {
            // Step 1: execute action `_adapter.CalculateRoundScores();`
            _adapter.CalculateRoundScores();
        } // end of behavior for ROUND_END
    }

    private void ROUND_END_exit()
    {
        // ROUND_END behavior
        // uml: exit / { _adapter.NotifyRoundEnded(); }
        {
            // Step 1: execute action `_adapter.NotifyRoundEnded();`
            _adapter.NotifyRoundEnded();
        } // end of behavior for ROUND_END

        this.stateId = StateId.ROOT;
    }

    private void ROUND_END_continuegame()
    {
        // ROUND_END behavior
        // uml: ContinueGame TransitionTo(DEALING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ROUND_END_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `DEALING`.
            DEALING_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROUND_END

        // No ancestor handles this event.
    }

    private void ROUND_END_winningscorereached()
    {
        // ROUND_END behavior
        // uml: WinningScoreReached TransitionTo(GAME_OVER)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ROUND_END_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `GAME_OVER`.
            GAME_OVER_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROUND_END

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TIMER_TIMEOUT
    ////////////////////////////////////////////////////////////////////////////////

    private void TIMER_TIMEOUT_enter()
    {
        this.stateId = StateId.TIMER_TIMEOUT;

        // TIMER_TIMEOUT behavior
        // uml: enter / { _adapter.DeductTimeoutPoints(); }
        {
            // Step 1: execute action `_adapter.DeductTimeoutPoints();`
            _adapter.DeductTimeoutPoints();
        } // end of behavior for TIMER_TIMEOUT
    }

    private void TIMER_TIMEOUT_exit()
    {
        // TIMER_TIMEOUT behavior
        // uml: exit / { _adapter.ResetPlayerTimer(); }
        {
            // Step 1: execute action `_adapter.ResetPlayerTimer();`
            _adapter.ResetPlayerTimer();
        } // end of behavior for TIMER_TIMEOUT

        this.stateId = StateId.ROOT;
    }

    private void TIMER_TIMEOUT_timerreset()
    {
        // TIMER_TIMEOUT behavior
        // uml: TimerReset TransitionTo(PLAYER_TURN)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            TIMER_TIMEOUT_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `PLAYER_TURN`.
            GAMEPLAY_enter();
            PLAYER_TURN_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for TIMER_TIMEOUT

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state TRUMP_SELECTION
    ////////////////////////////////////////////////////////////////////////////////

    private void TRUMP_SELECTION_enter()
    {
        this.stateId = StateId.TRUMP_SELECTION;

        // TRUMP_SELECTION behavior
        // uml: enter / { _adapter.FlipTrumpCard(); }
        {
            // Step 1: execute action `_adapter.FlipTrumpCard();`
            _adapter.FlipTrumpCard();
        } // end of behavior for TRUMP_SELECTION
    }

    private void TRUMP_SELECTION_exit()
    {
        // TRUMP_SELECTION behavior
        // uml: exit / { _adapter.NotifyTrumpDetermined(); }
        {
            // Step 1: execute action `_adapter.NotifyTrumpDetermined();`
            _adapter.NotifyTrumpDetermined();
        } // end of behavior for TRUMP_SELECTION

        this.stateId = StateId.ROOT;
    }

    private void TRUMP_SELECTION_trumpdetermined()
    {
        // TRUMP_SELECTION behavior
        // uml: TrumpDetermined TransitionTo(GAMEPLAY)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            TRUMP_SELECTION_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `GAMEPLAY`.
            GAMEPLAY_enter();

            // GAMEPLAY.<InitialState> behavior
            // uml: TransitionTo(PLAYER_TURN)
            {
                // Step 1: Exit states until we reach `GAMEPLAY` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `PLAYER_TURN`.
                PLAYER_TURN_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for GAMEPLAY.<InitialState>
        } // end of behavior for TRUMP_SELECTION

        // No ancestor handles this event.
    }

    // Thread safe.
    public static string StateIdToString(StateId id)
    {
        switch (id)
        {
            case StateId.ROOT: return "ROOT";
            case StateId.DEALING: return "DEALING";
            case StateId.GAME_INIT: return "GAME_INIT";
            case StateId.GAME_OVER: return "GAME_OVER";
            case StateId.GAMEPLAY: return "GAMEPLAY";
            case StateId.CARD_DRAW: return "CARD_DRAW";
            case StateId.DECK_CHECK: return "DECK_CHECK";
            case StateId.LAST_9_CARDS: return "LAST_9_CARDS";
            case StateId.L9_OPPONENT_RESPONSE: return "L9_OPPONENT_RESPONSE";
            case StateId.L9_PLAYER_TURN: return "L9_PLAYER_TURN";
            case StateId.L9_TIMER_TIMEOUT: return "L9_TIMER_TIMEOUT";
            case StateId.L9_TRICK_CHECK: return "L9_TRICK_CHECK";
            case StateId.L9_TRICK_RESOLUTION: return "L9_TRICK_RESOLUTION";
            case StateId.MELD_OPPORTUNITY: return "MELD_OPPORTUNITY";
            case StateId.MELD_SCORING: return "MELD_SCORING";
            case StateId.OPPONENT_RESPONSE: return "OPPONENT_RESPONSE";
            case StateId.PLAYER_TURN: return "PLAYER_TURN";
            case StateId.TRICK_RESOLUTION: return "TRICK_RESOLUTION";
            case StateId.ROUND_END: return "ROUND_END";
            case StateId.TIMER_TIMEOUT: return "TIMER_TIMEOUT";
            case StateId.TRUMP_SELECTION: return "TRUMP_SELECTION";
            default: return "?";
        }
    }

    // Thread safe.
    public static string EventIdToString(EventId id)
    {
        switch (id)
        {
            case EventId.ALLHANDSEMPTY: return "ALLHANDSEMPTY";
            case EventId.CARDPLAYED: return "CARDPLAYED";
            case EventId.CARDSDEALT: return "CARDSDEALT";
            case EventId.CARDSDRAWN: return "CARDSDRAWN";
            case EventId.CONTINUEGAME: return "CONTINUEGAME";
            case EventId.CONTINUELASTNINE: return "CONTINUELASTNINE";
            case EventId.DECKEMPTY: return "DECKEMPTY";
            case EventId.INITIALIZED: return "INITIALIZED";
            case EventId.MELDDECLARED: return "MELDDECLARED";
            case EventId.MELDSCORED: return "MELDSCORED";
            case EventId.MELDSKIPPED: return "MELDSKIPPED";
            case EventId.MORECARDSAVAILABLE: return "MORECARDSAVAILABLE";
            case EventId.MOREPLAYERSNEEDTOPLAY: return "MOREPLAYERSNEEDTOPLAY";
            case EventId.TIMEREXPIRED: return "TIMEREXPIRED";
            case EventId.TIMERRESET: return "TIMERRESET";
            case EventId.TRICKCOMPLETE: return "TRICKCOMPLETE";
            case EventId.TRICKRESOLVED: return "TRICKRESOLVED";
            case EventId.TRUMPDETERMINED: return "TRUMPDETERMINED";
            case EventId.WINNINGSCOREREACHED: return "WINNINGSCOREREACHED";
            default: return "?";
        }
    }
}
